# -*- coding: utf-8 -*-
"""Week3hds.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ih7H0rkpVjWydcbUtEfCTT6fPR8GW5H7

#importing required libraries
"""

import pandas as pd
import numpy as np
from math import *

"""OPENING AND READING THE DATA



"""

data= pd.read_csv('/content/clinics.csv', delimiter='|')#it is a pipe delimited file

data.head()# displaying 1st few rows of the data

#defining haversine function
def haversine(lat1, lon1, lat2, lon2):
    miles_constant = 3959
    lat1, lon1, lat2, lon2 = map(np.deg2rad, [lat1, lon1, lat2, lon2])
    dlat = lat2 - lat1
    dlon = lon2 - lon1
    a = np.sin(dlat/2)**2 + np.cos(lat1) * np.cos(lat2) * np.sin(dlon/2)**2
    c = 2 * np.arcsin(np.sqrt(a))
    return miles_constant * c

import time

lat_ref, lon_ref = 40.671, -73.985# reference point
distances = []

start = time.time()
haversine_series = []
for index, row in data.iterrows():
    haversine_series.append(haversine(40.671, -73.985,\
                                      row['locLat'], row['locLong']))
data['distance'] = haversine_series
end = time.time()



print(f"iterrows execution time: {end - start:.4f} seconds")

"""Using apply"""

start = time.time()
data['distance_apply'] = data.apply(lambda row: haversine(lat_ref, lon_ref, row['locLat'], row['locLong']), axis=1)
end = time.time()

print(f"Apply function execution time: {end - start:.4f} seconds")

"""vectorized Numpy"""

start = time.time()
data['distance_vectorized'] = haversine(lat_ref, lon_ref, data['locLat'], data['locLong'])
end = time.time()

print(f"Vectorized execution time: {end - start:.4f} seconds")



"""Cythonize Approach"""

# Commented out IPython magic to ensure Python compatibility.
# loading  the cython extension
# %load_ext Cython

"""Cythonized Haversine function"""

# Commented out IPython magic to ensure Python compatibility.
# %%cython -a
# 
# # Haversine cythonized (no other edits)
# import numpy as np
# cimport numpy as np
# 
# cpdef double haversine_cy(double lat1, double lon1, double lat2, double lon2):
#     cdef double miles_constant = 3959
#     lat1, lon1, lat2, lon2 = np.deg2rad([lat1, lon1, lat2, lon2])
#     cdef double dlat = lat2 - lat1
#     cdef double dlon = lon2 - lon1
#     cdef double a = np.sin(dlat/2)**2 + np.cos(lat1) * np.cos(lat2) * np.sin(dlon/2)**2
#     cdef double c = 2 * np.arcsin(np.sqrt(a))
#     return miles_constant * c
#

lat_ref, lon_ref = 40.671, -73.985  # Example reference location

# Compute distances using Cython function
data['distance_cython'] = data.apply(lambda row: haversine_cy(lat_ref, lon_ref, row['locLat'], row['locLong']), axis=1)

# Display results
print(data[['locLat', 'locLong', 'distance_cython']].head())

import time

start = time.time()
data['distance_cython'] = data.apply(lambda row: haversine_cy(lat_ref, lon_ref, row['locLat'], row['locLong']), axis=1)
end = time.time()

print(f"Cython Execution Time: {end - start:.4f} seconds")

"""Vectorized pandas"""

def haversine_pandas(df, lat_ref, lon_ref):
    """
    Compute Haversine distance in a fully vectorized Pandas approach.

    Parameters:
        df : Pandas DataFrame
        lat_ref : float - Reference latitude (in degrees)
        lon_ref : float - Reference longitude (in degrees)

    Returns:
        Pandas Series with distances in miles
    """
    miles_constant = 3959

    # Converting  degrees to radians using Pandas
    lat1, lon1 = np.radians(lat_ref), np.radians(lon_ref)
    lat2, lon2 = np.radians(df['locLat']), np.radians(df['locLong'])

    # Computing  differences
    dlat = lat2 - lat1
    dlon = lon2 - lon1

    # Haversine formula
    a = np.sin(dlat / 2) ** 2 + np.cos(lat1) * np.cos(lat2) * np.sin(dlon / 2) ** 2
    c = 2 * np.arcsin(np.sqrt(a))

    return miles_constant * c

lat_ref, lon_ref = 40.671, -73.985

# Computing distances using the Pandas
data['distance_pandas'] = haversine_pandas(data, lat_ref, lon_ref)

# Displaying  results
print(data[['locLat', 'locLong', 'distance_pandas']].head())

start = time.time()
data['distance_pandas'] = haversine_pandas(data, lat_ref, lon_ref)
end = time.time()

print(f"Pandas Vectorized Execution Time: {end - start:.4f} seconds")